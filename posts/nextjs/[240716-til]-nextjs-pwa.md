<p data-ke-size="size16">nextjs 14버전에서 pwa 를 셋업하는 방법에 대해 알아보았습니다.</p>
<h2 data-ke-size="size26">1. next-pwa 설치</h2>
<pre class="dockerfile"><code>yarn add next-pwa 
yarn add -D webpack</code></pre>
<h2 data-ke-size="size26">2. next.config.mjs 수정</h2>
<p data-ke-size="size16">아래와 같이 수정합니다.</p>
<pre class="cpp"><code>import withPWAInit from "next-pwa";
<p>const withPWA = withPWAInit({
dest: &quot;public&quot;,
});</p>
<p>/** @type {import('next').NextConfig} */
const nextConfig = {};</p>
<p>export default withPWA(nextConfig);</code></pre></p>
<h2 data-ke-size="size26">3. 퍼블릭에 manifest.json</h2>
<p data-ke-size="size16">/public 폴더에 아래와 같이 manifest.json 파일을 작성합니다.</p>
<pre class="json"><code>{
    "name": "My Next.js PWA",
    "short_name": "NextPWA",
    "description": "My awesome Next.js PWA!",
    "icons": [
        {
            "src": "/test_icon.png",
            "type": "image/png",
            "sizes": "192x192"
        },
        {
            "src": "/test_icon.png",
            "type": "image/png",
            "sizes": "512x512"
        }
    ],
    "start_url": "/",
    "background_color": "#ffffff",
    "theme_color": "#000000",
    "display": "standalone"
}</code></pre>
<h2 data-ke-size="size26">4. layout.tsx</h2>
<p data-ke-size="size16">루트 layout.tsx 에 아래와 같이 viewport 와 metadata 를 설정해줍니다.</p>
<pre class="dts"><code>export const viewport: Viewport = {
    themeColor: "black",
    width: "device-width",
    initialScale: 1,
    maximumScale: 1,
    userScalable: false,
    viewportFit: "cover",
};
<p>export const metadata: Metadata = {
title: &quot;Create Next App&quot;,
description: &quot;Generated by create next app&quot;,
manifest: &quot;/manifest.json&quot;,
icons: {
icon: &quot;/test_icon.png&quot;,
shortcut: &quot;/test_icon.png&quot;,
apple: &quot;/test_icon.png&quot;,
other: {
rel: &quot;apple-touch-icon-precomposed&quot;,
url: &quot;/test_icon.png&quot;,
},
},
};</code></pre></p>
<h2 data-ke-size="size26">5. 설치 유도</h2>
<h3 data-ke-size="size23">public/sw.js</h3>
<p data-ke-size="size16">설치 유도를 하려면, service worker와 BeforeInstallPromptEvent를 사용해야 합니다.</p>
<p data-ke-size="size16"><a href="https://developer.mozilla.org/en-US/docs/Web/API/BeforeInstallPromptEvent">https://developer.mozilla.org/en-US/docs/Web/API/BeforeInstallPromptEvent</a></p>
<p data-ke-size="size16">먼저, public/sw.js 파일을 작성합니다.</p>
<pre class="javascript"><code>// public/sw.js
import { clientsClaim } from 'workbox-core';
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
<p>clientsClaim();</p>
<p>// self.__WB_MANIFEST is injected by workbox-build during the build process
precacheAndRoute(self.__WB_MANIFEST || []);</p>
<p>// Cache CSS, JS, and web worker requests with a network-first strategy.
registerRoute(
({ request }) =&gt; request.destination === 'style' || request.destination === 'script' || request.destination === 'worker',
new NetworkFirst({
cacheName: 'static-resources',
})
);</p>
<p>// Cache image files with a cache-first strategy.
registerRoute(
({ request }) =&gt; request.destination === 'image',
new CacheFirst({
cacheName: 'images',
plugins: [
new ExpirationPlugin({
maxEntries: 50,
}),
],
})
);</p>
<p>// Cache API calls with a network-first strategy.
registerRoute(
({ url }) =&gt; url.pathname.startsWith('/api/'),
new NetworkFirst({
cacheName: 'api',
networkTimeoutSeconds: 10,
plugins: [
new CacheableResponsePlugin({
statuses: [0, 200],
}),
],
})
);</p>
<p>// Cache the start URL with a network-first strategy.
registerRoute(
'/',
new NetworkFirst({
cacheName: 'start-url',
plugins: [
{
cacheWillUpdate: async ({ request, response }) =&gt; {
if (response &amp;&amp; response.type === 'opaqueredirect') {
return new Response(response.body, {
status: 200,
statusText: 'OK',
headers: response.headers,
});
}
return response;
},
},
],
})
);</p>
<p>// Cache everything else with a network-only strategy.
registerRoute(
({ request }) =&gt; true,
new CacheFirst({
cacheName: 'catch-all',
})
);</code></pre></p>
<h3 data-ke-size="size23">utils/isPWA.ts</h3>
<pre class="typescript"><code>export const isPWA = (): boolean =&gt; {
    return (
        window.matchMedia("(display-mode: standalone)").matches ||
            (window.navigator as any).standalone === true
    );
};</code></pre>
<p data-ke-size="size16">위 코드는 주소창 존재 여부를 판별해 줍니다.<br />그리하여 현재 앱이 pwa 모드로 작동되고있는지를 판별할 수 있습니다.</p>
<h3 data-ke-size="size23">응용.useCheckPwa</h3>
<p data-ke-size="size16">유틸함수를 응용하여 아래처럼 훅을 만들 수 있을 것 같습니다.</p>
<pre class="typescript"><code>import { useEffect, useState } from 'react';
<p>const useCheckPwa = (): boolean =&gt; {
const [isPwa, setIsPwa] = useState(false);</p>
<pre><code>useEffect(() =&amp;gt; {
    const checkPwa = (): boolean =&amp;gt; {
    return window.matchMedia('(display-mode: standalone)').matches 
    || (window.navigator as any).standalone === true;
};

setIsPwa(checkPwa());
}, []);

return isPwa;
</code></pre>
<p>};</p>
<p>export default useCheckPwa;</code></pre></p>
<h3 data-ke-size="size23">버튼 컴포넌트</h3>
<p data-ke-size="size16">실험결과, 자동으로 판단해서 설치프롬프트를 띄워줄 수는 없습니다.<br />특히 모바일에서 사용자 상호작용이 없이는 안되더라고요.</p>
<p data-ke-size="size16">그래서 아래처럼 버튼 컴포넌트로 만들 수 있습니다.</p>
<pre class="typescript"><code>"use client";
<p>import useCheckPwa from '@/hooks/useCheckPwa';
import { useEffect, useState } from 'react';</p>
<p>const InstallPromptHandler = () =&gt; {
const [deferredPrompt, setDeferredPrompt] = useState&lt;Event | null&gt;(null);
const isPwa = useCheckPwa();</p>
<pre><code>useEffect(() =&amp;gt; {
    const handler = (e: Event) =&amp;gt; {
        e.preventDefault();
        setDeferredPrompt(e);
    };

    window.addEventListener('beforeinstallprompt', handler as any);

    return () =&amp;gt; {
        window.removeEventListener('beforeinstallprompt', handler as any);
    };
}, []);


const handleInstallClick = () =&amp;gt; {
    if (deferredPrompt) {
        (deferredPrompt as any).prompt();
        (deferredPrompt as any).userChoice.then((choiceResult: any) =&amp;gt; {
            if (choiceResult.outcome === 'accepted') {
                console.log('User accepted the install prompt');
            } else {
                console.log('User dismissed the install prompt');
            }
            setDeferredPrompt(null);
        });
    }
};


if (isPwa) {
    return null;
}


if (!isPwa) {
    return (
        &amp;lt;button
            onClick={handleInstallClick}
            className=&quot;bg-blue-500 text-white px-4 py-2 rounded-md&quot;
        &amp;gt;            
        홈 화면에 추가하기
        &amp;lt;/button&amp;gt;
    &amp;lt;/&amp;gt;
    )
}
</code></pre>
<p>};</p>
<p>export default InstallPromptHandler;</code></pre></p>
<p data-ke-size="size16">그런데 아직 모바일에서 프롬프트가 잘 안표시되는 증상이 있어서 개선이 필요합니다!</p>